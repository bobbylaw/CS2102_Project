--add_course
/*
This routine is used to add a new course. 
The inputs to the routine include the following: course title, course description, course area, and duration. 
The course identifier is generated by the system.

*/
CREATE OR REPLACE PROCEDURE add_course(IN course_title TEXT, IN course_description TEXT, IN course_area TEXT, IN course_duration INTEGER)
AS $$
BEGIN

    INSERT INTO Courses(name, title, duration, description)
        VALUES (course_area, course_title, course_duration, course_description); --areas are inserted when the manager is inserted.

END
$$ LANGUAGE plpgsql;

--find_rooms
/*This routine is used to find all the rooms that could be used for a course session. 
The inputs to the routine include the following: session date, session start hour, and session duration. 
The routine returns a table of room identifiers.*/

CREATE OR REPLACE FUNCTION find_rooms(IN input_session_date DATE, IN input_start_hour INTEGER, IN input_duration INTEGER)
RETURNS TABLE (room_id INTEGER)
AS $$
BEGIN

    RETURN query (
        SELECT rid AS room_id
        FROM Rooms 
        EXCEPT
        SELECT rid AS room_id
        FROM Sessions s
        WHERE input_session_date = session_date
        AND (
            (input_start_hour < extract(hour from time start_time) 
            AND (input_start_hour + input_duration) > extract(hour from time start_time) 
            AND (input_start_hour + input_duration) < extract(hour from time end_time)) 
            OR 
            (input_start_hour >= extract(hour from time start_time) 
            AND input_start_hour < extract(hour from time end_time) 
            AND (input_start_hour + input_duration) > extract(hour from time end_time))
            OR
            (input_start_hour >= extract(hour from time start_time) 
            AND input_start_hour <= extract(hour from time end_time) 
            AND (input_start_hour + input_duration) >= extract(hour from time start_time)
            AND (input_start_hour + input_duration) <= extract(hour from time end_time))
            OR
            (input_start_hour < extract(hour from time start_time) 
            AND input_start_hour < extract(hour from time end_time) 
            AND (input_start_hour + input_duration) > extract(hour from time start_time)
            AND (input_start_hour + input_duration) > extract(hour from time end_time))
        )

    );

END
$$ LANGUAGE plpgsql;

--get_available_rooms
/*This routine is used to retrieve the availability information of rooms for a specific duration. 
The inputs to the routine include a start date and an end date. 
The routine returns a table of records consisting of the following information: room identifier, room capacity, 
day (which is within the input date range [start date, end date]), and an array of the hours that the room is available on the specified day. 
The output is sorted in ascending order of room identifier and day, and the array entries are sorted in ascending order of hour.*/
CREATE OR REPLACE FUNCTION get_available_rooms(IN input_start_date DATE, IN input_end_date DATE)
RETURNS TABLE (room_id INTEGER, room_capacity INTEGER, day DATE, available_hours TIME[])
AS $$
DECLARE
    curs CURSOR FOR (
        SELECT rid, capacity 
        FROM Rooms
        ORDER BY rid ASC
    );
    r RECORD;
    start_date_helper DATE;
    start_time_helper TIME;
    is_avail INTEGER;
    available_hours_helper TIME[] DEFAULT '{}';
BEGIN
    start_date_helper := input_start_date;
    start_time_helper := '09:00:00';
    is_avail := 1;

    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        LOOP
            EXIT WHEN start_date_helper = input_end_date + 1;

            is_avail := 1;

            IF start_time_helper = '18:00:00' THEN -- 6pm no more lessons.
                IF array_length(available_hours_helper, 1) > 0 THEN
                    room_id := r.rid;
                    room_capacity := r.capacity;
                    day := start_date_helper;
                    available_hours := available_hours_helper;
                    RETURN NEXT;
                END IF;
                start_time_helper := '09:00:00'; -- Earliest lesson at 9
                start_date_helper := start_date_helper + INTERVAL '1 day'; -- Next day
            ELSIF start_time_helper = '12:00:00' THEN
                start_time_helper := '14:00:00';
            ELSE
                SELECT 0 INTO is_avail 
                FROM Sessions 
                WHERE Session.rid = r.rid
                AND Sessions.session_date = start_date_helper
                AND (start_time_helper BETWEEN Sessions.start_time AND Sessions.end_time)
                LIMIT 1; -- In case of multiple entry.

                IF is_avail = 1 THEN
                    SELECT ARRAY_APPEND(available_hours, start_time_helper) INTO available_hours;
                END IF;
                start_time_helper := start_time_helper + INTERVAL '1 hour';
            END IF;
        END LOOP;
        start_date_helper := start_date_helper + 1;
        start_time_helper := '09:00:00';
    END LOOP;
    CLOSE curs;

END;
$$ LANGUAGE plpgsql;


--add_course_package
/*This routine is used to add a new course package for sale. 
The inputs to the routine include the following: package name, number of free course sessions, 
start and end date indicating the duration that the promotional package is available for sale, and the price of the package. 
The course package identifier is generated by the system. 
If the course package information is valid, the routine will perform the necessary updates to add the new course package.*/

--Course_packages package_id should be serial！！！
CREATE OR REPLACE PROCEDURE add_course_package(IN input_package_name TEXT, IN input_num_free_registration INTEGER, IN input_sales_start_date DATE, IN input_sales_end_date DATE, IN input_price NUMERIC(12,2))
AS $$
BEGIN

    INSERT INTO Course_packages(sales_start_date, sales_end_date, num_free_registration, name, price)
        VALUES (input_sales_start_date, input_sales_end_date, input_num_free_registration, input_package_name, input_price);

END
$$ LANGUAGE plpgsql;

--get_available_course_packages
/*This routine is used to retrieve the course packages that are available for sale. 
The routine returns a table of records with the following information for each available course package: 
package name, number of free course sessions, end date for promotional package, and the price of the package.*/
CREATE OR REPLACE FUNCTION get_available_course_packages()
RETURNS TABLE (package_name TEXT, num_free_sessions INTEGER, end_date DATE, price NUMERIC(12,2))
AS $$
BEGIN

    RETURN query (
        SELECT name AS package_name, num_free_registration AS num_free_sessions, sales_end_date AS end_date, price AS price
        FROM Course_packages 
        WHERE sales_start_date <= cast(now() as DATE) 
        AND sales_end_date >= cast(now() as DATE)
    );

END
$$ LANGUAGE plpgsql;

--buy_course_package
/*This routine is used when a customer requests to purchase a course package. 
The inputs to the routine include the customer and course package identifiers. 
If the purchase transaction is valid, the routine will process the purchase with the necessary updates (e.g., payment).*/

--only cust_id is given, which card should be used?
CREATE OR REPLACE PROCEDURE buy_course_package(IN input_customer_id INTEGER, IN input_package_id INTEGER)
AS $$
DECLARE
    credit_card TEXT;
    num_free_sessions INTEGER;
    start_date DATE;
    end_date DATE;
    now_date DATE;
BEGIN
    credit_card := (SELECT card_number
                    FROM Owns_credit_cards
                    WHERE cust_id = input_customer_id
                    LIMIT 1);

    num_free_sessions := (SELECT num_free_registration 
                          FROM Course_packages
                          WHERE package_id = input_package_id);

    start_date := (SELECT sales_start_date
                   FROM Course_packages
                   WHERE package_id = input_package_id);
    
    end_date := (SELECT sales_end_date
                FROM Course_packages
                WHERE package_id = input_package_id);

    now_date := CAST(NOW() AS DATE);
    
    IF (sales_start_date <= now_date AND sales_end_date >= now_date) 
    THEN
        INSERT INTO Buys(card_number, package_id, purchase_date, num_of_redemption)
        VALUES (credit_card, input_package_id, now_date, num_free_sessions);

END
$$ LANGUAGE plpgsql;


--get_my_course_package
/*This routine is used when a customer requests to view his/her active/partially active course package. 
The input to the routine is a customer identifier. 
The routine returns the following information as a JSON value: package name, purchase date, price of package, number of free sessions included in the package, number of sessions that have not been redeemed, and information for each redeemed session (course name, session date, session start hour). 
The redeemed session information is sorted in ascending order of session date and start hour.*/

CREATE OR REPLACE FUNCTION get_my_course_packages(IN input_email TEXT)
RETURNS RETURNS TABLE(json_obj json)
AS $$
DECLARE 
    package_name TEXT;
    num_free_sessions INTEGER;
    num_unredeem_sessions INTEGER;
    purchase_date DATE;
    price NUMERIC(12,2); 
    num_redeemed INTEGER;
    session_start_time TIME;
    session_date DATE;
    course_name TEXT;
    customer_id INTEGER;
    pid INTEGER;
BEGIN

    SELECT cust_id INTO customer_id
    FROM CustomerS
    WHERE email = input_email;


    SELECT name, num_free_registrations, num_of_redemption, purchase_date, price, package_id INTO package_name, num_free_sessions, num_unredeem_sessions, purchase_date, price, pid     
    FROM Course_packages NATURAL JOIN BUYS NATURAL JOIN Owns_credit_cards
    WHERE Owns_credit_cards.cust_id = customer_id
    AND num_of_redemption > 0 
    OR (num_of_redemption = 0 AND EXISTS (
                                    SELECT 1 FROM Redeems NATURAL JOIN Owns_credit_cards
                                    WHERE Owns_credit_cards.cust_id = customer_id
                                    AND refemption_date - CAST(NOW() AS DATE) >= 7));

    SELECT jsonb_build_object(
	    --'package name', C.name, 'number of free sessions', C.num_free_registrations, 'number of sessions left', B.num_of_redemption, 
	    'package name', package_name, 'number of free sessions', num_free_registrations, 'number of sessions left', num_unredeemed_sessions, 
        'info of redeemed sessions' , 
        (SELECT COALESCE(jsonb_agg(jsonb_build_object('course name', C.course_name, 'session date', S.session_date, 'start time', S.start_time)) , '[]')
		    FROM Redeems AS R NATURAL JOIN Courses AS C NATURAL JOIN Sessions AS S NATURAL JOIN Owns_credit_cards AS O
            WHERE O.cust_id = customer_id 
            AND R.package_id = pid
            AND R.purchase_date = purchase_date
            AND C.course_id = R.course_id
            ORDER BY S.session_date, S.start_time ASC
        )
	) AS json_obj;
    
END;
$$ LANGUAGE plpgsql;
        
--top_packages
/*This routine is used to find the top N course packages in terms of the total number of packages sold for this year 
(i.e., the package’s start date is within this year). 
The input to the routine is a positive integer number N. 
The routine returns a table of records consisting of the following information for each of the top N course packages: 
package identifier, number of included free course sessions, price of package, start date, end date, and number of packages sold. 
The output is sorted in descending order of number of packages sold followed by descending order of price of package. 
In the event that there are multiple packages that tie for the top Nth position, all these packages should be included in the output records; 
thus, the output table could have more than N records. It is also possible for the output table to have fewer than N records if N is larger than the number of packages launched this year.
*/
--create a CTE to calculate the top n number
CREATE OR REPLACE FUNCTION top_packages(IN input_n INTEGER)
RETURNS TABLE (package_identifier INTEGER, num_sessions INTEGER, price_package INTEGER, start_date DATE, end_date DATE, num_sold INTEGER)
AS $$
DECLARE
    
BEGIN
    WITH pkg_info AS (
        SELECT package_id, count(*) AS num_sales
        FROM Buys NATURAL JOIN Course_packages
        WHERE CAST(sales_start_date AS YEAR) = CAST(NOW() AS YEAR)
        GROUP BY package_id
        ORDER BY num_sales ASC
    )

    SELECT package_id, num_free_registrations, price, sales_start_date, sales_end_date, num_sales 
    INTO package_identifier, num_sessions, price_package, start_date, end_date, num_sold 
    FROM Buys NATURAL JOIN Course_packages NATURAL JOIN pkg_info
    WHERE CAST(sales_start_date AS YEAR) = CAST(NOW() AS YEAR)
    AND EXISTS (
        SELECT 1 FROM
        (SELECT DISTINCT num_sales 
        FROM pkg_info
        LIMIT N
        ) AS New_sales
		WHERE num_sales = New_sales.num_sales
    )
    ORDER BY num_sales, price DES;
END
$$ LANGUAGE plpgsql;
