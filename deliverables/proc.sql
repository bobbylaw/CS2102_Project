/* ============================================================== FUNCTIONS ============================================================== */
-- 1.add_employee:
/*
This routine is used to add a new employee. 
The inputs to the routine include the following: 
    name, home address, contact number, email address, 
    salary information (i.e., monthly salary for a full-time employee or hourly rate for a part-time employee), 
    date that the employee joined the company, 
    the employee category (manager, administrator, or instructor), 
    and a (possibly empty) set of course areas. 
If the new employee is a manager, the set of course areas refers to the areas that are managed by the manager. 
If the new employee is an instructor, the set of course areas refers to the instructor’s specialization areas. 
The set of course areas must be empty if the new employee is a administrator; and non-empty, otherwise. 
The employee identifier is generated by the system.
*/
/*Explanation
1. Check whether input is valid
	- catagory must be manager, administrator or instructor
	- course areas cannot be NULL when it is an instructor
	- course areas not NULL when it is an administrator
	- salary rate is hourly when it is a manager or administrator
	- salary rate not equals to 'monthly' or 'hourly'
2. Insert into Employee first followed by inserting into respectively tables based on catagory and rate
*/
CREATE OR REPLACE PROCEDURE add_employee(name TEXT, home_address TEXT, contact_number TEXT, email_address TEXT, salary_information SALARY_INFORMATION, join_date DATE, catagory TEXT, course_areas TEXT[] DEFAULT NULL)
AS $$
DECLARE
	eid INTEGER := 0;
BEGIN
	IF catagory ISNULL or (catagory <> 'manager' and catagory <> 'administrator' and catagory <> 'instructor') THEN
		RAISE EXCEPTION 'OPERATION FAILED: please specify the employee catagory correctly';
	ELSIF course_areas ISNULL AND catagory = 'instructor' THEN
		RAISE EXCEPTION 'OPERATION FAILED: missing course_areas when employee is instructor';
	ELSIF course_areas NOTNULL AND catagory = 'administrator' THEN
		RAISE EXCEPTION 'OPERATION FAILED: course_areas presented when employee is administrator';
	ELSIF (salary_information.rate) != 'hourly' AND (salary_information.rate) != 'monthly' THEN
		RAISE EXCEPTION 'OPERATION FAILED: missing salary information';
	ELSIF (salary_information.rate) = 'hourly' AND (catagory = 'manager' or catagory = 'administrator') THEN
		RAISE EXCEPTION 'OPERATION FAILED: Only Instructor can be part-time';
	END IF;
	
	INSERT INTO Employees (name, address, email, join_date, phone) VALUES(name, home_address, email_address, join_date, contact_number);
	
	-- Get latest eid number from Employees table
	SELECT currval(pg_get_serial_sequence('Employees', 'eid')) into eid;

	IF catagory = 'manager' THEN
		INSERT INTO full_time_emp (eid, monthly_salary) VALUES (eid, salary_information);
		INSERT INTO Managers (eid) VALUES (eid);
		INSERT INTO course_areas (name, eid)
		SELECT course_area, eid FROM unnest(course_areas) AS course_area;
	ELSIF catagory = 'administrator' THEN
		INSERT INTO full_time_emp (eid, monthly_salary) VALUES (eid, salary_information);
		INSERT INTO Administrators (eid) VALUES (eid);
	ELSIF catagory = 'instructor' THEN
		INSERT INTO instructors (eid, course_area)
		SELECT eid, course_area FROM unnest(course_areas) AS course_area;
		IF (salary_information).rate = 'monthly' THEN
			INSERT INTO full_time_emp (eid, monthly_salary) VALUES (eid, salary_information);
			INSERT INTO full_time_instructors (eid, course_area)
			SELECT eid, course_area FROM unnest(course_areas) AS course_area;
		ELSIF (salary_information).rate = 'hourly' THEN
			INSERT INTO part_time_emp (eid, hourly_rate) VALUES (eid, salary_information);
			INSERT INTO part_time_instructors (eid, course_area)
			SELECT eid, course_area FROM unnest(course_areas) AS course_area;
		END IF;
	END IF;
END;
$$ LANGUAGE plpgsql;

-- 2.remove_employee:
/*
This routine is used to update an employee’s departed date a non-null value. 
The inputs to the routine is an employee identifier and a departure date. 
The update operation is rejected if any one of the following conditions hold: 
    (1) the employee is an administrator who is handling some course offering where its registration deadline is after the employee’s departure date; 
    (2) the employee is an instructor who is teaching some course session that starts after the employee’s departure date; or 
    (3) the employee is a manager who is managing some area.
*/
/*Explanation
1. Check if EID exist inside Employee table
2. Get respective count for 
	(1) the employee is an administrator who is handling some course offering where its registration deadline is after the employee’s departure date
	(2) the employee is an instructor who is teaching some course session that starts after the employee’s departure date
	(3) the employee is a manager who is managing some area
3. Only updates if all count is 0
*/
CREATE OR REPLACE PROCEDURE remove_employee(employee_id INTEGER, departure_date DATE) AS $$
DECLARE
	eid_handling_course_offering_count INTEGER := 0;
	eid_teaching_course_count INTEGER := 0;
	eid_managing_area_count INTEGER := 0;
BEGIN

	-- Check if EID exist
	IF NOT EXISTS(SELECT * from Employees where eid = employee_id) THEN
		RAISE NOTICE 'Employee ID do not exist';
		RETURN;
	END IF;
	
	SELECT count(*) INTO eid_handling_course_offering_count
	FROM Offerings O
	WHERE O.eid = employee_id AND O.registration_date > departure_date;
	
	SELECT count(*) INTO eid_teaching_course_count
	FROM Sessions S
	WHERE S.eid = employee_id;
	
	SELECT count(*) INTO eid_managing_area_count
	FROM Course_areas C
	WHERE C.eid = employee_id;
	
	IF eid_handling_course_offering_count = 0 AND eid_teaching_course_count = 0 AND eid_managing_area_count = 0 THEN
		UPDATE Employees
		SET depart_date = departure_date
		WHERE eid = employee_id;
		RAISE NOTICE 'OPERATION SUCCESS';
	ELSE
		RAISE NOTICE 'OPERATION FAILED: Employee is currently still tied to some work';
	END IF;
END;
$$ LANGUAGE plpgsql;

-- 3.add_customer:
/*
This routine is used to add a new customer. 
The inputs to the routine include the following: name, home address, contact number, email address, and credit card details (credit card number, expiry date, CVV code). 
The customer identifier is generated by the system.
*/
CREATE OR REPLACE PROCEDURE add_customer(IN input_cust_name TEXT, IN input_address TEXT, IN input_phone TEXT, IN input_email TEXT, IN input_card_number TEXT, IN input_expiry_date DATE, IN input_CVV INTEGER)
AS $$
DECLARE
    customer_id INTEGER;
BEGIN

    INSERT INTO Customers(name, address, phone, email)
        VALUES (input_cust_name, input_address, input_phone, input_email);

    SELECT c.cust_id into customer_id
        FROM Customers as c
        WHERE input_email = c.email; -- email is unique, so this identifies a unique cust_id

    INSERT INTO Owns_credit_cards(card_number, cust_id, CVV, from_date, expiry_date)
        VALUES(input_card_number, customer_id, input_CVV, NOW(), input_expiry_date);

END
$$ LANGUAGE plpgsql;

-- 4.update_credit_card:
/* 
This routine is used when a customer requests to change his/her credit card details. 
The inputs to the routine include the customer identifier and his/her new credit card details (credit card number, expiry date, CVV code).
*/
CREATE OR REPLACE PROCEDURE update_credit_card(IN input_email TEXT, IN input_card_number TEXT, IN input_expiry_date DATE, IN input_CVV INTEGER)
AS $$
DECLARE
    customer_id INTEGER;
BEGIN

    SELECT c.cust_id into customer_id
        FROM Customers as c
        WHERE input_email = c.email; -- email is unique, so this identifies a unique cust_id
    
    UPDATE Owns_credit_cards
        SET card_number = input_card_number,
            CVV = input_CVV,
            expiry_date = input_expiry_date
    WHERE customer_id = cust_id;

END
$$ LANGUAGE plpgsql;

-- 5.add_course:
/*
This routine is used to add a new course. 
The inputs to the routine include the following: course title, course description, course area, and duration. 
The course identifier is generated by the system.
*/

-- 6.find_instructors:
/*
This routine is used to find all the instructors who could be assigned to teach a course session. 
The inputs to the routine include the following: course identifier, session date, and session start hour. 
The routine returns a table of records consisting of employee identifier and name.
*/

CREATE OR REPLACE FUNCTION find_instructors(IN course_id1 INTEGER, IN session_date1 DATE, IN start_time1 TIME)
RETURNS TABLE(eid INT, name TEXT) AS $$
DECLARE
    curs CURSOR FOR (SELECT Employees.eid, Employees.name FROM Employees -- Instructors can teach course_id1 and avaliable on session_date1
        WHERE Employees.eid IN (
            SELECT Instructors.eid FROM Instructors
                WHERE Instructors.course_area = (SELECT Courses.name FROM Courses WHERE Courses.course_id = course_id1)
        )
        AND Employees.depart_date IS NULL -- Meaning the employees is still in the company.
    );
    r RECORD;
    is_unavail INTEGER;
    course_duration INTERVAL;
BEGIN
    SELECT duration INTO course_duration
    FROM Courses
    WHERE Courses.course_id = course_id1;

    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        
        SELECT COUNT(*) INTO is_unavail FROM Sessions -- Instructor already has a session clashing with the start_time
        WHERE r.eid = Sessions.eid 
        AND (start_time1, start_time1 + course_duration) OVERLAPS ((Sessions.start_time - INTERVAL '1 hour'), (Sessions.end_time + INTERVAL '1 hour'))
        AND session_date1 = Sessions.session_date;

        IF is_unavail = 0 THEN
            eid := r.eid;
            name := r.name;
            RETURN NEXT;
        END IF;
    END LOOP;
    CLOSE curs;
END;
$$ LANGUAGE plpgsql;

-- 7.get_available_instructors: 
/*
This routine is used to retrieve the availability information of instructors who could be assigned to teach a specified course. 
The inputs to the routine include the following: course identifier, start date, and end date. 
The routine returns a table of records consisting of the following information: 
    employee identifier, name, total number of teaching hours that the instructor has been assigned for this month, 
    day (which is within the input date range [start date, end date]), and an array of the available hours for the instructor on the specified day. 
The output is sorted in ascending order of employee identifier and day, and the array entries are sorted in ascending order of hour.
*/

/*
Things to note: The array of the available hours for the instructor is the hour that the instructor is able to teach the session.
So 12pm and 6pm is automatically not in the array.

Eg. The course duration is 2 hours and the instructor has that course session from 4pm-6pm. It available hours are 9am and 10am.
11 am is invalid because 11am-1pm is invalid. 2pm is invalid because 2pm-4pm clashes with 3pm-6pm. (include rest time)
*/
CREATE OR REPLACE FUNCTION get_available_instructors(IN course_identifier INTEGER, IN start_date DATE, IN end_date DATE)
RETURNS TABLE(eid INTEGER, total_teaching_hours INTERVAL, month INTEGER, day INTEGER, available_hours TIME[]) AS $$ -- Or use [] for array?
DECLARE
    curs CURSOR FOR (SELECT Employees.eid, Employees.name FROM Employees
        WHERE Employees.eid IN (
            SELECT Instructors.eid FROM Instructors
                WHERE Instructors.course_area = (SELECT Courses.name FROM Courses WHERE Courses.course_id = course_identifier)
        )
        ORDER BY eid ASC
    );
    r RECORD;
    start_date_helper DATE;
    start_time_helper TIME;
    is_unavail INTEGER;
    total_teaching_hours_helper INTERVAL;
    available_hours_helper TIME[];
    course_duration INTERVAL;
BEGIN
    start_date_helper := start_date;
    start_time_helper := '09:00:00';
    is_unavail := 0;
    total_teaching_hours_helper := INTERVAL '0 hour';
    available_hours_helper := '{}';

    SELECT duration INTO course_duration
    FROM Courses
    WHERE Courses.course_id = course_identifier;

    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        LOOP
            EXIT WHEN start_date_helper = (end_date + INTERVAL '1 day');

            is_unavail := 0;

            SELECT SUM(end_time - start_time) INTO total_teaching_hours_helper FROM Sessions
            WHERE Sessions.course_id = course_identifier
            AND Sessions.eid = r.eid
            AND EXTRACT(Month FROM start_date_helper) = EXTRACT(Month FROM Sessions.session_date);

            IF start_time_helper = ('18:00:00' - course_duration + INTERVAL '1 hour') THEN
                IF array_length(available_hours_helper, 1) > 0 THEN
                    eid := r.eid;
                    total_teaching_hours := total_teaching_hours_helper;
                    SELECT EXTRACT(Month FROM start_date_helper) INTO month;
                    SELECT EXTRACT(Day FROM start_date_helper) INTO day;
                    available_hours := available_hours_helper;
                    RETURN NEXT;
                END IF;
                start_time_helper := '09:00:00'; -- Earliest lesson at 9
                start_date_helper := start_date_helper + INTERVAL '1 day'; -- Next day
                available_hours_helper := '{}';
            ELSIF start_time_helper = ('12:00:00' - course_duration + INTERVAL '1 hour') THEN
                start_time_helper := '14:00:00';
            ELSE
                SELECT COUNT(*) INTO is_unavail FROM Sessions 
                WHERE Sessions.course_id = course_identifier
                AND Sessions.eid = r.eid
                AND Sessions.session_date = start_date_helper
                AND (start_time_helper, start_time_helper + course_duration) OVERLAPS ((Sessions.start_time - INTERVAL '1 hour'), (Sessions.end_time + INTERVAL '1 hour'));

                IF is_unavail = 0 THEN
                    SELECT ARRAY_APPEND(available_hours_helper, start_time_helper) INTO available_hours_helper;
                END IF;
                start_time_helper := start_time_helper + INTERVAL '1 hour';
            END IF;
        END LOOP;
        start_date_helper := start_date;
        start_time_helper := '09:00:00';
    END LOOP;
    CLOSE curs;
END;
$$ LANGUAGE plpgsql;


-- 8.find_rooms: 
/*
This routine is used to find all the rooms that could be used for a course session. 
The inputs to the routine include the following: session date, session start hour, and session duration. 
The routine returns a table of room identifiers.
*/

-- 9.get_available_rooms: 
/*
This routine is used to retrieve the availability information of rooms for a specific duration. 
The inputs to the routine include a start date and an end date. 
The routine returns a table of records consisting of the following information: 
    room identifier, room capacity, day (which is within the input date range [start date, end date]), 
    and an array of the hours that the room is available on the specified day. 
The output is sorted in ascending order of room identifier and day, and the array entries are sorted in ascending order of hour.
*/

-- 10.add_course_offering: 
/*
This routine is used to add a new offering of an existing course. 
The inputs to the routine include the following: 
    course offering identifier, course identifier, course fees, launch date, registration deadline, administrator’s identifier, 
    and information for each session (session date, session start hour, and room identifier). 
If the input course offering information is valid, the routine will assign instructors for the sessions. 
If a valid instructor assignment exists, the routine will perform the necessary updates to add the course offering; 
    otherwise, the routine will abort the course offering addition. 
Note that the seating capacity of the course offering must be at least equal to the course offering’s target number of registrations.
*/
/*Explanation
1. Check whether input is valid
	- First session start date must be 10 days more than registration_deadline
	- target number of registration larger than total number of seating capacity
2. Check session input is valid
	- Session must be from Monday to Friday
	- Session time must be from 9am to 12pm or 2pm to 6pm
	- Session start time must be before end time
3. Insert course_offering into Offering table
4. For each Session,
	- pick the first instructor available using find_instructor
	- get the course_area related to this instructor
	- INSERT session into Session table
*/
CREATE OR REPLACE PROCEDURE add_course_offerings (_course_id INTEGER, course_fees NUMERIC(12,2), launch_date DATE, registration_deadline DATE, target_number_of_registration INTEGER, administrator_id INTEGER, session_info SESSION_INFORMATION[])
AS $$
DECLARE
	available_instructor_id INTEGER;
	first_session_date DATE;
	last_session_date DATE;
	session_end_time TIME;
	total_seating_capacity INTEGER;
	sessions SESSION_INFORMATION;
	instructor_available INTEGER;
	course_area_of_instructor TEXT;
BEGIN
	SELECT session_date INTO first_session_date
	FROM unnest(session_info)
	ORDER BY session_date ASC
	LIMIT 1;
	
	SELECT session_date INTO last_session_date
	FROM unnest(session_info)
	ORDER BY session_date DESC
	LIMIT 1;
	
	SELECT sum(seating_capacity) into total_seating_capacity
	FROM unnest(session_info) join Rooms ON room_id = rid;
	
	IF  (SELECT(CAST(first_session_date AS DATE) - CAST(registration_deadline AS DATE))) < 10 THEN
		RAISE EXCEPTION 'OPERATION FAILED: First session start date must be 10 days more than registration_deadline';
	ELSIF total_seating_capacity < target_number_of_registration THEN
		RAISE EXCEPTION 'OPERATION FAILED: target number of registration larger than total number of seating capacity';
	END IF;
	
	FOREACH sessions in ARRAY session_info LOOP
		session_end_time := (sessions).session_start_time + (SELECT duration FROM Courses C WHERE C.course_id = _course_id);
		IF EXTRACT(isodow FROM (sessions).session_date) not in (1,2,3,4,5) THEN
			RAISE EXCEPTION 'OPERATION FAILED: Session must be from Monday to Friday';
		ELSIF (EXTRACT(hours FROM (sessions).session_start_time) < 9 OR EXTRACT(hours FROM session_end_time) > 12) AND (EXTRACT(hours FROM (sessions).session_start_time) < 14 OR EXTRACT(hours FROM session_end_time) > 18) THEN
			RAISE EXCEPTION 'OPERATION FAILED: Session time must be from 9am to 12pm or 2pm to 6pm';
		ELSIF (EXTRACT(hours FROM session_end_time)) <= (EXTRACT(hours FROM (sessions).session_start_time)) THEN
			RAISE EXCEPTION 'OPERATION FAILED: Session start time must be before end time';
		END IF;
		
		instructor_available := (SELECT eid FROM find_instructors(_course_id, (sessions).session_date, (sessions).session_start_time) LIMIT 1); -- check if there is at least 1 instructor available
		IF instructor_available ISNULL THEN
			RAISE EXCEPTION 'OPERATION FAILED: Unable to find instructor for Session date % of Course ID: % launching on  %', (sessions).session_date, _course_id, launch_date;
		END IF;
	END LOOP;
	
	INSERT INTO Offerings (course_id, launch_date, start_date, eid, end_date, registration_deadline, target_number_registrations, seating_capacity, fees) VALUES (_course_id, launch_date, first_session_date, administrator_id, last_session_date, registration_deadline, target_number_of_registration, total_seating_capacity, course_fees);
	
	FOREACH sessions in ARRAY session_info LOOP
		session_end_time := (sessions).session_start_time + (SELECT duration FROM Courses C WHERE C.course_id = _course_id);
		instructor_available := (SELECT eid FROM find_instructors(_course_id, (sessions).session_date, (sessions).session_start_time) LIMIT 1);
		course_area_of_instructor := (SELECT name FROM Courses C WHERE C.course_id = _course_id);
		INSERT INTO Sessions(course_id, launch_date, course_area, rid, eid, session_date, start_time, end_time)
		VALUES (_course_id, launch_date, course_area_of_instructor, (sessions).room_id, instructor_available, (sessions).session_date, (sessions).session_start_time, session_end_time);
	END LOOP;
	ALTER SEQUENCE sessions_sid_seq RESTART;
END;
$$ LANGUAGE plpgsql;

-- 11.add_course_package: 
/*
This routine is used to add a new course package for sale. 
The inputs to the routine include the following: 
    package name, number of free course sessions, start and 
    end date indicating the duration that the promotional package is available for sale, 
    and the price of the package. 
The course package identifier is generated by the system. 
If the course package information is valid, the routine will perform the necessary updates to add the new course package.
*/

-- 12.get_available_course_packages: 
/*
This routine is used to retrieve the course packages that are available for sale. 
The routine returns a table of records with the following information for each available course package: 
    package name, number of free course sessions, end date for promotional package, and the price of the package.
*/

-- 13.buy_course_package: 
/*
This routine is used when a customer requests to purchase a course package. 
The inputs to the routine include the customer and course package identifiers. 
If the purchase transaction is valid, the routine will process the purchase with the necessary updates (e.g., payment).
*/

-- 14.get_my_course_package: 
/*
This routine is used when a customer requests to view his/her active/partially active course package. 
The input to the routine is a customer identifier. 
The routine returns the following information as a JSON value: 
    package name, purchase date, price of package, 
    number of free sessions included in the package, 
    number of sessions that have not been redeemed, 
    and information for each redeemed session (course name, session date, session start hour). 
The redeemed session information is sorted in ascending order of session date and start hour.
*/

-- 15.get_available_course_offerings: 
/*
This routine is used to retrieve all the available course offerings that could be registered. 
The routine returns a table of records with the following information for each course offering: 
    course title, course area, start date, end date, registration deadline, course fees, 
    and the number of remaining seats. 
The output is sorted in ascending order of registration deadline and course title.
*/
/*Explanation
1. Get all course_offerings detail including course_area, title using join operation
2. Calculate the remaining num of registration left based on target_num_registration - (count(Register) + count(Redeem)) where course_id and launch_date is the same
3. Return table
*/
CREATE OR REPLACE FUNCTION get_available_course_offerings()
RETURNS TABLE(course_title TEXT, course_area TEXT, start_date DATE, end_date DATE, registration_deadline DATE,course_fees NUMERIC(12,2),num_of_remaining_seats INTEGER) AS $$
DECLARE
	curs CURSOR FOR (SELECT * FROM Offerings O join Courses C on O.course_id = C.course_id WHERE O.registration_deadline - CURRENT_DATE > 0 ORDER BY registration_deadline, title ASC );
	count_register INTEGER;
	count_redeem INTEGER;
	r RECORD;
BEGIN
	OPEN curs;
	LOOP
		FETCH curs INTO r;
		EXIT WHEN NOT FOUND;
		start_date := r.start_date;
		end_date := r.end_date;
		registration_deadline := r.registration_deadline;
		course_fees := r.fees;
		course_title := r.title;
		course_area := r.name;
			  
		SELECT count(*) INTO count_register
		FROM Registers T
		WHERE T.course_id = r.course_id and T.launch_date = r.launch_date;
			  
		SELECT count(*) INTO count_redeem
		FROM Redeems T
		WHERE T.course_id = r.course_id and T.launch_date = r.launch_date;
			  
		num_of_remaining_seats := r.target_number_registrations - count_register - count_redeem;
		IF num_of_remaining_seats > 0 THEN
			RETURN NEXT;
		END IF;
	END LOOP;
	CLOSE curs;
END;
$$ LANGUAGE plpgsql;

-- 16.get_available_course_sessions:
/* 
This routine is used to retrieve all the available sessions for a course offering that could be registered. 
The input to the routine is a course offering identifier. 
The routine returns a table of records with the following information for each available session: session date, session start hour, instructor name, and number of remaining seats for that session. 
The output is sorted in ascending order of session date and start hour.
*/
CREATE OR REPLACE FUNCTION get_available_course_sessions(IN input_course_id INTEGER, IN input_launch_date DATE)
RETURNS TABLE (session_date DATE, start_hour float, instructor_name TEXT, remaining_seats BIGINT)
AS $$
BEGIN

    RETURN query (
        SELECT s.session_date as session_date, EXTRACT(hours from s.start_time) as start_hour, e.name as instructor_name, (o.seating_capacity - COUNT(re.redemption_date) - COUNT(r.card_number)) as remaining_seats
        FROM Registers as r NATURAL FULL JOIN Redeems as re NATURAL FULL JOIN Sessions as s NATURAL FULL JOIN (SELECT course_id, launch_date, start_date, seating_capacity FROM Offerings) as o NATURAL FULL JOIN Instructors as i NATURAL FULL JOIN Employees as e
        GROUP BY s.session_date, s.start_time, e.name, o.seating_capacity, o.course_id, o.launch_date
        HAVING input_course_id = o.course_id AND input_launch_date = o.launch_date AND o.seating_capacity - COUNT(re.redemption_date) - COUNT(r.card_number) > 0
        ORDER BY session_date, start_hour
    );

END
$$ LANGUAGE plpgsql;

-- 17.register_session: 
/*
This routine is used when a customer requests to register for a session in a course offering. 
The inputs to the routine include the following:
    customer identifier, course offering identifier, session number, 
    and payment method (credit card or redemption from active package). 
If the registration transaction is valid, this routine will process the registration with the necessary updates (e.g., payment/redemption).
*/

/*
Things to note:
- When a customer register for a course session, we use his first credit card to register. (credit card not given)
*/
CREATE OR REPLACE PROCEDURE register_sessions(IN customer_id INTEGER, IN course_identifier INTEGER, IN offering_launch_date DATE, IN session_id INTEGER, payment_method TEXT)
AS $$
DECLARE
    curs CURSOR FOR (SELECT card_number FROM Owns_credit_cards WHERE Owns_credit_cards.cust_id = customer_id);
    r RECORD;
    is_redeem INTEGER;
    is_register INTEGER;
    customer_cc_num TEXT;
    redeem_package_id INTEGER;
    package_purchase_date DATE;
BEGIN
    is_redeem := 0;
    is_register := 0;

    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;

        SELECT COUNT(*) INTO is_redeem  -- Check whether custoemr redeems or purchase the session
        FROM Redeems
        WHERE Redeems.course_id = course_identifier 
        AND Redeems.launch_date = offering_launch_date 
        AND Redeems.card_number = r.card_number;

        SELECT COUNT(*) INTO is_register
        FROM Registers
        WHERE Registers.course_id = course_identifier
        AND Registers.launch_date = offering_launch_date
        AND Registers.card_number = r.card_number;

        IF is_redeem > 0 OR is_register > 0 THEN
            CLOSE curs;
            RAISE EXCEPTION 'This customer has already redeem or register for this course offering';
        END IF;
    END LOOP;
    CLOSE curs;
    
    SELECT card_number INTO customer_cc_num FROM Owns_credit_cards 
    WHERE Owns_credit_cards.cust_id = customer_id 
    LIMIT 1; -- If customer has multiple cc card then we choose the first.

    IF payment_method = 'credit card' THEN -- insert into register table.
        INSERT INTO Registers VALUES (customer_cc_num, course_identifier, offering_launch_date, session_id, CURRENT_DATE);
    ELSIF payment_method = 'redemption' THEN -- insert into redeems table
        OPEN curs;
        LOOP
            FETCH curs INTO r;
            EXIT WHEN NOT FOUND;

            redeem_package_id := 0;

            SELECT package_id INTO redeem_package_id FROM Buys
            WHERE Buys.card_number = r.card_number
            AND num_of_redemption > 0;

            SELECT purchase_date INTO package_purchase_date FROM Buys
            WHERE Buys.card_number = r.card_number
            AND num_of_redemption > 0;

            IF redeem_package_id <> 0 THEN
                INSERT INTO Redeems VALUES (r.card_number, redeem_package_id, package_purchase_date, course_identifier, offering_launch_date, session_id, CURRENT_DATE);

                UPDATE Buys SET num_of_redemption = num_of_redemption - 1
                WHERE card_number = r.card_number
                AND package_id = redeem_package_id
                AND purchase_date = package_purchase_date;
            END IF;
        END LOOP;
    ELSE
        RAISE EXCEPTION 'Payment method has to be stated in credit card or redemption';
    END IF;
END;
$$ LANGUAGE plpgsql;


-- 18.get_my_registrations
/*
This routine is used when a customer requests to view his/her active course registrations (i.e, registrations for course sessions that have not ended). 
The input to the routine is a customer identifier. 
The routine returns a table of records with the following information for each active registration session: course name, course fees, session date, session start hour, session duration, and instructor name. 
The output is sorted in ascending order of session date and session start hour.
*/

CREATE OR REPLACE FUNCTION get_my_registrations(IN cust_email TEXT)
RETURNS TABLE (course_name TEXT, course_fees NUMERIC(12, 2), session_date DATE, start_hour float, session_duration float, instructor_name TEXT)
AS $$
BEGIN

    RETURN query (
        SELECT cse_name as course_name, COALESCE(o.fees, 0) as course_fees, s.session_date as session_date, EXTRACT(hours from s.start_time) as start_hour, COALESCE(EXTRACT(minutes from (s.end_time - s.start_time)), 0) as session_duration, ename as instructor_name
        FROM Customers as c NATURAL FULL JOIN Owns_credit_cards as occ NATURAL FULL JOIN Buys as b NATURAL FULL JOIN Registers as r NATURAL FULL JOIN Sessions as s NATURAL FULL JOIN (SELECT course_id, launch_date, start_date, seating_capacity, fees, end_date FROM Offerings) as o NATURAL FULL JOIN Instructors as i NATURAL FULL JOIN (SELECT eid, name as ename FROM Employees) as e NATURAL FULL JOIN (SELECT course_id, name as cse_name FROM Courses) as cse
        WHERE cust_email = c.email 
            AND now() <= o.end_date -- not ended condition
            AND b.num_of_redemption > 0 -- is active condition
        ORDER BY session_date, start_hour
    );

END
$$ LANGUAGE plpgsql;

-- 19.update_course_session
/*
This routine is used when a customer requests to change a registered course session to another session. 
The inputs to the routine include the following: customer identifier, course offering identifier, and new session number. 
If the update request is valid and there is an available seat in the new session, the routine will process the request with the necessary updates.
*/

CREATE OR REPLACE PROCEDURE update_course_session(IN input_cust_email TEXT, IN input_course_id INTEGER, IN input_launch_date DATE, IN input_sid INTEGER)
AS $$
DECLARE
    avail_capacity INTEGER;
    old_sid INTEGER;
    customer_card_number TEXT;
BEGIN
    avail_capacity := (SELECT COALESCE((o.seating_capacity - COUNT(r.card_number)), 0) as remaining_seats -- coalesce 0 is if newly chosen session does not exist
                        FROM registers as r NATURAL JOIN Sessions as s NATURAL JOIN (SELECT launch_date, course_id, seating_capacity FROM Offerings) as o
                        GROUP BY o.seating_capacity, course_id, launch_date, sid
                        HAVING input_course_id = course_id AND 
                            input_launch_date = launch_date AND
                            input_sid = sid);
    
    IF (avail_capacity <= 0) THEN -- handles validity and avail check here
        RAISE EXCEPTION 'There isnt an availible seat in the selected session!';
    ELSE
        customer_card_number := (
            SELECT card_number
            FROM Customers as c NATURAL JOIN Owns_Credit_Cards as o
            WHERE c.email = input_cust_email
        );

        old_sid := ( -- allowed because for each course offered by the company, a customer can register for at most one of its sessions before its registration deadline
            SELECT sid
            FROM Registers as r
            WHERE input_course_id = course_id
                AND input_launch_date = launch_date
                AND customer_card_number = card_number
            LIMIT 1
        );

        UPDATE Registers
        SET sid = input_sid
        WHERE old_sid = sid
            AND input_course_id = course_id
            AND input_launch_date = launch_date
            AND customer_card_number = card_number;
    END IF;
END
$$ LANGUAGE plpgsql;

-- 20.cancel_registration: 
/*
This routine is used when a customer requests to cancel a registered course session. 
The inputs to the routine include the following: customer identifier, and course offering identifier. 
If the cancellation request is valid, the routine will process the request with the necessary updates.
*/

/*
Things to note:
- A customer can ONLY have 1 register/redeem for each COURSE OFFERING.
- A customer can owns multiple credit card. Hence we iterate through the credit cards and check which credit card
    the customer use to register/redeem the course session. 
*/
CREATE OR REPLACE PROCEDURE cancel_registration(IN customer_id INTEGER, IN course_identifier INTEGER, IN offering_launch_date DATE)
AS $$
DECLARE
    curs1 CURSOR FOR (SELECT card_number FROM Owns_credit_cards WHERE Owns_credit_cards.cust_id = customer_id);
    r RECORD;
    is_redeem INTEGER;
    is_register INTEGER;
    course_offering_price NUMERIC(12,2);
    session_id INTEGER;
BEGIN
    is_redeem := 0;
    is_register := 0;
    course_offering_price := 0;

    SELECT fees INTO course_offering_price -- Get the price of the course session/offerings. Its the same.
    FROM Offerings
    WHERE Offerings.course_id = course_identifier
    AND Offerings.launch_date = offering_launch_date;

    OPEN curs1;
    LOOP
        FETCH curs1 INTO r;
        EXIT WHEN NOT FOUND;

        SELECT COUNT(*) INTO is_redeem  -- Check whether customer redeems or purchase the session
        FROM Redeems
        WHERE Redeems.course_id = course_identifier 
        AND Redeems.launch_date = offering_launch_date 
        AND Redeems.card_number = r.card_number
        AND CURRENT_DATE - Redeems.purchase_date <= 7;

        SELECT COUNT(*) INTO is_register
        FROM Registers
        WHERE Registers.course_id = course_identifier
        AND Registers.launch_date = offering_launch_date
        AND Registers.card_number = r.card_number
        AND CURRENT_DATE - Registers.registration_date <= 7;

        IF (is_redeem > 0) THEN
            SELECT sid INTO session_id FROM Redeems
            WHERE Redeems.course_id = course_identifier 
            AND Redeems.launch_date = offering_launch_date 
            AND Redeems.card_number = r.card_number
            AND CURRENT_DATE - Redeems.purchase_date <= 7
            LIMIT 1;

            INSERT INTO Cancels
            VALUES (customer_id, course_identifier, offering_launch_date, session_id, CURRENT_DATE, 0, 1); 

        ELSIF (is_register > 0) THEN
            SELECT sid INTO session_id
            FROM Registers
            WHERE Registers.course_id = course_identifier
            AND Registers.launch_date = offering_launch_date
            AND Registers.card_number = r.card_number
            AND CURRENT_DATE - Registers.registration_date <= 7
            LIMIT 1;

            INSERT INTO Cancels
            VALUES (customer_id, course_identifier, offering_launch_date, session_id, CURRENT_DATE, 0.9 * course_offering_price, 0);
        END IF;
    END LOOP;
    CLOSE curs1;
END;
$$ LANGUAGE plpgsql;

-- 21.update_instructor: 
/*
This routine is used to change the instructor for a course session. 
The inputs to the routine include the following: 
    course offering identifier, session number, and identifier of the new instructor. 
If the course session has not yet started and the update request is valid, the routine will process the request with the necessary updates.
*/

/*
Things to note:
The way we interpret the update request is valid is if the instructor are able to teach the course session assign to him.
So, there shouldn't be a clash of session timing taught by the instructor after the update. 
*/
CREATE OR REPLACE PROCEDURE update_instructor(IN course_identifier INTEGER, IN offering_launch_date DATE, IN session_id INTEGER, IN new_eid INTEGER)
AS $$
DECLARE
    course_session_start_time TIME;
    course_session_date DATE;
    course_duration INTERVAL;
    is_invalid_update INTEGER;
BEGIN
    is_invalid_update := 0;

    SELECT start_time INTO course_session_start_time
    FROM Sessions
    WHERE Sessions.course_id = course_identifier
    AND Sessions.launch_date = offering_launch_date
    AND Sessions.sid = session_id;
	
	SELECT session_date INTO course_session_date
    FROM Sessions
    WHERE Sessions.course_id = course_identifier
    AND Sessions.launch_date = offering_launch_date
    AND Sessions.sid = session_id;

    SELECT duration INTO course_duration FROM courses
    WHERE courses.course_id = course_identifier;

    SELECT COUNT(*) INTO is_invalid_update FROM Sessions
    WHERE Sessions.course_id = course_identifier
    AND Sessions.eid = new_eid
    AND Sessions.session_date = course_session_date
    AND Sessions.sid <> session_id
    AND (course_session_start_time, course_session_start_time + course_duration) OVERLAPS
        (Sessions.start_time - INTERVAL '1 hour', Sessions.end_time + INTERVAL '1 hour');
	
    IF (CURRENT_TIME < course_session_start_time) AND (CURRENT_DATE <= course_session_date) 
        AND (is_invalid_update = 0) THEN
            UPDATE Sessions
            SET eid = new_eid
            WHERE Sessions.course_id = course_identifier
            AND Sessions.launch_date = offering_launch_date
            AND Sessions.sid = session_id;
    ELSE
        RAISE EXCEPTION 'The course session has started or it is invalid update request';
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 22.update_room: 
/*
This routine is used to change the room for a course session. 
The inputs to the routine include the following: 
    course offering identifier, session number, and identifier of the new room. 
If the course session has not yet started and the update request is valid, the routine will process the request with the necessary updates. 
Note that update request should not be performed if the number of registrations for the session exceeds the seating capacity of the new room.
*/

/*
Things to note:
- The number of customer going to attend the course is the sum of the customers who registered for the course and customers who redeem
    from their course_package.
- A customer can only register or redeems a session from a course offering.
*/
CREATE OR REPLACE PROCEDURE update_room(IN course_identifier INTEGER, IN offering_launch_date DATE, IN session_id INTEGER, IN new_rid INTEGER)
AS $$
DECLARE
    course_session_start_time TIME;
    course_session_date DATE;
    new_room_seating_capacity INTEGER;
    num_of_registration INTEGER;
    num_of_redemption INTEGER;
BEGIN
    SELECT start_time INTO course_session_start_time
    FROM Sessions
    WHERE Sessions.course_id = course_identifier
    AND Sessions.launch_date = offering_launch_date
    AND Sessions.sid = session_id;

    SELECT session_date INTO course_session_date
    FROM Sessions
    WHERE Sessions.course_id = course_identifier
    AND Sessions.launch_date = offering_launch_date
    AND Sessions.sid = session_id;

    SELECT seating_capacity INTO new_room_seating_capacity
    FROM Rooms
    WHERE Rooms.rid = new_rid;

    SELECT COUNT(*) INTO num_of_registration
    FROM Registers
    WHERE Registers.course_id = course_identifier
    AND Registers.launch_date = offering_launch_date
    AND Registers.sid = session_id;

    SELECT COUNT(*) INTO num_of_redemption
    FROM Redeems
    WHERE Redeems.course_id = course_identifier
    AND Redeems.launch_date = offering_launch_date
    AND Redeems.sid = session_id;

    IF (CURRENT_DATE <= course_session_date) AND (CURRENT_TIME < course_session_start_time)
        AND ((num_of_registration + num_of_redemption) <= new_room_seating_capacity) THEN
            UPDATE Sessions
            SET rid = new_rid
            WHERE Sessions.course_id = course_identifier
            AND Sessions.launch_date = offering_launch_date
            AND Sessions.sid = session_id;
    ELSE
        RAISE EXCEPTION 'The course probably has started or the new room doesnt have enough seating capacity';
    END IF;
END;
$$ LANGUAGE plpgsql;


-- 23.remove_session:
/*
This routine is used to remove a course session. 
The inputs to the routine include the following: course offering identifier and session number. 
If the course session has not yet started and the request is valid, the routine will process the request with the necessary updates. 
The request must not be performed if there is at least one registration for the session. 
Note that the resultant seating capacity of the course offering could fall below the course offering’s target number of registrations, which is allowed.
*/

CREATE OR REPLACE PROCEDURE remove_session(IN input_course_id INTEGER, IN input_launch_date DATE, IN input_sid INTEGER)
AS $$
DECLARE
    num_registration INTEGER;
    num_redemption INTEGER;
    has_started BOOLEAN;
BEGIN
    num_registration := (
        SELECT COUNT(*)
        FROM Registers
        WHERE input_course_id = course_id
            AND input_launch_date = launch_date
            AND input_sid = sid
    );

    num_redemption := (
        SELECT COUNT(*)
        FROM Redeems
        WHERE input_course_id = course_id
            AND input_launch_date = launch_date
            AND input_sid = sid
    );

    IF (num_registration <> 0 OR num_redemption <> 0) THEN
        RAISE EXCEPTION 'There are existing registrations for this session!';
    END IF;

    has_started := (
        SELECT now() >= s.start_time
        FROM Sessions as s
        WHERE input_course_id = course_id
            AND input_launch_date = launch_date
            AND input_sid = sid
    );

    IF (has_started) THEN
        RAISE EXCEPTION 'Session has already started!';
    ELSE 
        DELETE FROM Sessions
        WHERE input_course_id = course_id
            AND input_launch_date = launch_date
            AND input_sid = sid;
    END IF;
END
$$ LANGUAGE plpgsql;

-- 24.add_session:
/*
This routine is used to add a new session to a course offering. 
The inputs to the routine include the following: course offering identifier, new session number, new session day, new session start hour, instructor identifier for new session, and room identifier for new session. 
If the course offering’s registration deadline has not passed and the the addition request is valid, the routine will process the request with the necessary updates.
*/

CREATE OR REPLACE PROCEDURE add_session(IN input_course_id INTEGER, IN input_launch_date DATE, IN input_sid INTEGER, IN input_session_day DATE, IN input_session_start_hour TIME, IN input_instructor_eid INTEGER, IN input_rid INTEGER)
AS $$
DECLARE
    is_valid_session BOOLEAN;
    input_course_area TEXT;
    input_course_duration INTERVAL;
BEGIN
    is_valid_session := (
        SELECT input_session_day <= o.registration_deadline
        FROM Offerings as o
        WHERE input_course_id = course_id
            AND input_launch_date = launch_date
    );

    input_course_area := (
        SELECT name
        FROM Courses
        WHERE course_id = input_course_id
    );

    input_course_duration := (
        SELECT duration
        FROM Courses
        WHERE course_id = input_course_id
    );

    IF (is_valid_session) THEN
        INSERT INTO Sessions(course_id, launch_date, course_area, rid, eid, sid, session_date, start_time, end_time)
        VALUES (input_course_id, input_launch_date, input_course_area, input_rid, input_instructor_eid, input_sid, input_session_day, input_session_start_hour, input_session_start_hour + input_course_duration);
    ELSE
        RAISE EXCEPTION 'Invalid sessions added!';
    END IF;
END
$$ LANGUAGE plpgsql;

-- 25.pay_salary: 
/*
This routine is used at the end of the month to pay salaries to employees. 
The routine inserts the new salary payment records and returns a table of records (sorted in ascending order of employee identifier) 
with the following information for each employee who is paid for the month: 
    employee identifier, name, status (either part-time or full-time), number of work days for the month, number of work hours for the month, 
    hourly rate, monthly salary, and salary amount paid. For a part-time employees, the values for number of work days for the month and monthly salary should be null. 
For a full-time employees, the values for number of work hours for the month and hourly rate should be null.
*/
/*Explanation
1. Calculate the start_of_month, end_of_month, days_in_month
2. Open cursor for full_time union part_time <-- due to this, monthly_salary will be the common attribute for salary information
3. Calculate salary based on work_days(not including sat/sun)/total_month * monthly_salary for full time and work_hour * hourly_rate for part time
4. insert salary into pay_slip table
*/
CREATE OR REPLACE FUNCTION pay_salary()
RETURNS TABLE(employee_id INTEGER, employee_name TEXT, status TEXT, num_work_days INTEGER, num_work_hours INTEGER, hourly_rate INTEGER, monthly_salary INTEGER, salary_amount_paid NUMERIC(5,2)) AS $$
DECLARE
	curs CURSOR FOR (SELECT * FROM employees natural join full_time_emp union SELECT * FROM employees natural join part_time_emp);
	start_of_month DATE;
	end_of_month DATE;
	days_in_month INTEGER;
	work_days INTEGER;
	work_hours INTEGER;
	r RECORD;
BEGIN
	start_of_month := (SELECT DATE_TRUNC('MONTH', CURRENT_DATE));
	end_of_month := (SELECT DATE_TRUNC('MONTH', CURRENT_DATE) + interval '1 month - 1 day');
	days_in_month := (SELECT count(*) FROM generate_series(start_of_month, end_of_month, interval  '1 day'));
	OPEN curs;
	LOOP
		FETCH curs INTO r;
		EXIT WHEN NOT FOUND;
		employee_id := r.eid;
		employee_name := r.name;
		IF (r.monthly_salary).rate = 'monthly' THEN
			status := 'full-time';
			num_work_hours := NULL;
			hourly_rate := NULL;
			monthly_salary := (r.monthly_salary).salary;
			IF r.join_date BETWEEN start_of_month AND end_of_month THEN
				start_of_month := r.join_date;
			ELSIF r.depart_date BETWEEN start_of_month AND end_of_month THEN
				end_of_month := r.depart_date;
			END IF;
			work_days := (SELECT count(*) FROM generate_series(start_of_month, end_of_month, interval  '1 day') the_day WHERE  extract('ISODOW' FROM the_day) < 6);
			num_work_days := COALESCE(work_days, 0);
			salary_amount_paid := COALESCE(ROUND(((r.monthly_salary).salary * (work_days::NUMERIC / days_in_month::NUMERIC)),2),0);
		ELSIF (r.monthly_salary).rate = 'hourly' THEN
			status := 'part-time';
			num_work_days := NULL;
			num_work_hours := (SELECT SUM(EXTRACT('hours' FROM (end_time - start_time))) FROM Sessions S WHERE S.eid = r.eid AND S.session_date BETWEEN start_of_month AND end_of_month);
			num_work_hours := COALESCE(num_work_hours, 0);
			hourly_rate := (r.monthly_salary).salary;
			salary_amount_paid := COALESCE((num_work_hours * (r.monthly_salary).salary),0);
		END IF;
		RETURN NEXT;
		INSERT INTO Pay_slips (eid, payment_date, amount, num_work_hours, num_work_days) VALUES (employee_id, CURRENT_DATE, salary_amount_paid, num_work_hours, num_work_days);
	END LOOP;
	CLOSE curs;
END;
$$ LANGUAGE plpgsql;

-- 26.promote_courses: 
/*
This routine is used to identify potential course offerings that could be of interest to inactive customers. 
A customer is classified as an active customer if the customer has registered for some course offering in the last six months (inclusive of the current month); 
otherwise, the customer is considered to be inactive customer. 
A course area A is of interest to a customer C if there is some course offering in area A among the three most recent course offerings registered by C. 
If a customer has not yet registered for any course offering, we assume that every course area is of interest to that customer. 
The routine returns a table of records consisting of the following information for each inactive customer: 
    customer identifier, customer name, course area A that is of interest to the customer, course identifier of a course C in area A, course title of C, 
    launch date of course offering of course C that still accepts registrations, course offering’s registration deadline, and fees for the course offering. 
The output is sorted in ascending order of customer identifier and course offering’s registration deadline.
*/
/*Explanation
1. Get latest registration of each customer where the register_date is 6 months after current date (inactive customer)
2. Get customer information using the card_number from the latest registration (inactive customer)
3. For each customer, get the latest 3 registation course_id, course_area,
using this course_area, fetch offering that match the course_area.
insert the values into output table
4. For customer that has not register a course, find all offering available and output since all course_area is of interest
*/
CREATE OR REPLACE FUNCTION promote_courses() 
RETURNS TABLE(customer_id INTEGER, customer_name TEXT, course_area TEXT, _course_id INTEGER, course_title TEXT, course_launch_date DATE, course_registration_deadline DATE, course_fees NUMERIC(12,2)) AS $$
DECLARE
	curs1 CURSOR FOR (SELECT DISTINCT ON (cust_id) *
			FROM Customers natural join Owns_credit_cards natural left join Registers
            WHERE CURRENT_DATE - registration_date >= 180
			ORDER BY cust_id);
	r1 RECORD;
	
	curs2 refcursor;
	r2 RECORD;
BEGIN
	OPEN curs1;
	LOOP
		FETCH curs1 into r1;
		EXIT WHEN NOT FOUND;
		--check if customer register before
		IF r1.registration_date ISNULL THEN
			-- get all offering available since customer has never register before and all area is of interest
			OPEN curs2 FOR (SELECT course_id, launch_date, registration_deadline, fees FROM Offerings O WHERE registration_deadline - CURRENT_DATE > 0 ORDER BY registration_deadline ASC);
			LOOP
				FETCH curs2 into r2;
				EXIT WHEN NOT FOUND;
				customer_id := r1.cust_id;
				customer_name := r1.name;
				_course_id := r2.course_id;
				course_area := (SELECT name FROM Courses C WHERE C.course_id = r2.course_id);
				course_title := (SELECT title FROM Courses C WHERE C.course_id = r2.course_id);
				course_launch_date := r2.launch_date;
				course_registration_deadline := r2.registration_deadline;
				course_fees := r2.fees;
				RETURN NEXT;
			END LOOP;
			CLOSE curs2;
		ELSE
			--get three latest course registration for each inactive customer, foreach course_area, find the offering available
			OPEN curs2 FOR (SELECT * FROM Offerings O natural join (SELECT C.name, R.course_id, title FROM Registers R natural join Courses C WHERE R.card_number = r1.card_number LIMIT 3) AS R WHERE registration_deadline - CURRENT_DATE > 0 ORDER BY registration_deadline ASC);
			LOOP
				FETCH curs2 into r2;
				EXIT WHEN NOT FOUND;
				customer_id := r1.cust_id;
				customer_name := r1.name; --customer name
				_course_id := r2.course_id;
				course_area := r2.name; --course name
				course_title := r2.title;
				course_launch_date := r2.launch_date;
				course_registration_deadline := r2.registration_deadline;
				course_fees := r2.fees;
				RETURN NEXT;
			END LOOP;
			CLOSE curs2;
		END IF;
	END LOOP;
	CLOSE curs1;

END
$$ LANGUAGE plpgsql;

-- 27.top_packages: 
/*
This routine is used to find the top N course packages in terms of the total number of packages sold for this year (i.e., the package’s start date is within this year). 
The input to the routine is a positive integer number N. 
The routine returns a table of records consisting of the following information for each of the top N course packages: 
    package identifier, number of included free course sessions, price of package, start date, end date, and number of packages sold. 
The output is sorted in descending order of number of packages sold followed by descending order of price of package. 
In the event that there are multiple packages that tie for the top Nth position, all these packages should be included in the output records; thus, the output table could have more than N records. 
It is also possible for the output table to have fewer than N records if N is larger than the number of packages launched this year.
*/

-- 28.popular_courses:
/*
This routine is used to find the popular courses offered this year (i.e., start date is within this year). 
A course is popular if 
    the course has at least two offerings this year, 
    and for every pair of offerings of the course this year, 
        the offering with the later start date has a higher number of registrations than that of the offering with the earlier start date. 
The routine returns a table of records consisting of the following information for each popular course: 
    course identifier, course title, course area, number of offerings this year, and number of registrations for the latest offering this year. 
The output is sorted in descending order of the number of registrations for the latest offering this year followed by in ascending order of course identifier.
*/

CREATE OR REPLACE FUNCTION popular_courses_driver()
RETURNS TABLE (output_course_id INTEGER, 
                output_course_title TEXT, 
                output_course_area TEXT, 
                output_number_of_offerings INTEGER, 
                output_num_registration_latest_offering INTEGER)
AS $$
DECLARE
    curs1 CURSOR FOR (
        SELECT DISTINCT course_id, name, title, duration
        FROM Offerings as o NATURAL JOIN Courses as c
        WHERE EXTRACT(years FROM now()) = EXTRACT(years from o.start_date)
        ORDER BY course_id
    );
    r1 record;

    curs2 refcursor;
    r2 record;

    curs3 refcursor;
    r3 record;

    curr_course_id INTEGER;
    curr_course_name TEXT;
    curr_course_title TEXT;
    curr_course_duration INTERVAL;

    later_launch_date DATE;
    later_start_date DATE;
    later_num_reg INTEGER;

    earlier_start_date DATE;
    earlier_num_reg INTEGER;

    is_popular BOOLEAN;
    num_offerings INTEGER;

BEGIN
    OPEN curs1; -- this returns offerings that occured this year
    LOOP -- loop through all the courses
        FETCH curs1 into r1;
        EXIT WHEN NOT FOUND;

        is_popular := 1; -- assume course is popular until counter example

        curr_course_id := r1.course_id;
        curr_course_name := r1.name;
        curr_course_title := r1.title;
        curr_course_duration := r1.duration;

        num_offerings := (
            SELECT count(*)
            FROM Offerings as o1
            WHERE curr_course_id = course_id -- select the correct courses
        );

        IF (num_offerings >= 2) THEN -- only allows courses with num_offerings >= 2
            OPEN curs2 FOR ( -- loops through all of offerings that has this course_id
                SELECT *
                FROM Offerings as o1
                WHERE curr_course_id = course_id -- select the correct courses
                ORDER BY start_date
            );

            LOOP
                FETCH curs2 into r2;
                EXIT WHEN NOT FOUND;

                output_course_id := curr_course_id;
                output_course_title := curr_course_title;
                output_course_area := curr_course_name;
                output_number_of_offerings := num_offerings;

                later_start_date := r2.start_date;
                later_launch_date := r2.launch_date;
                later_num_reg := (
                    SELECT COUNT(r.card_number)
                    FROM Registers as r NATURAL JOIN Offerings as o
                    WHERE curr_course_id = course_id -- select the correct courses
                        AND later_launch_date = launch_date -- select the correct offering
                        AND later_start_date = start_date -- select the later start_date
                );

                OPEN curs3 FOR ( -- this curs is for looping through all the offerings with earlier start_dates
                    SELECT *
                    FROM Registers as r NATURAL FULL JOIN Offerings as o -- do full join incase no one registered for offering
                    WHERE curr_course_id = course_id -- select the correct courses
                        AND start_date < later_start_date  -- if start date is earlier
                    ORDER BY start_date
                );

                LOOP -- loops through all earlier start dates
                    FETCH curs3 into r3;
                    EXIT WHEN NOT FOUND;

                    earlier_num_reg := (
                        SELECT COUNT(r.card_number)
                        FROM Registers as r NATURAL FULL JOIN Offerings as o -- do full join incase no one registered for offering
                        WHERE curr_course_id = course_id -- select the correct courses
                            AND r3.launch_date = launch_date -- select correct offering
                            AND r3.start_date = start_date  -- select the corresponding earlier start date
                    );

                    IF (earlier_num_reg >= later_num_reg) THEN -- since we want all later_num_reg > earlier_num_reg, counter eg is when later_num_reg <= earlier_num_reg
                        is_popular := 0; -- counter example found when there exist an earlier offering with more or equals number_of_registration
                    END IF;
                    
                END LOOP;
                CLOSE curs3;

                output_num_registration_latest_offering := later_num_reg; -- this is guranteeed to be latest offering as curs2 is sorted by start_date
            END LOOP;
            CLOSE curs2;

            IF (is_popular) THEN
                RETURN NEXT; -- if it went through all the pairs and haven't found a counter example, then insert into answer
            END IF;

        END IF;

    END LOOP;
    CLOSE curs1;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION popular_courses() -- wrapper function so orderby ezpz
RETURNS TABLE (output_course_id INTEGER, 
                output_course_title TEXT, 
                output_course_area TEXT, 
                output_number_of_offerings INTEGER, 
                output_num_registration_latest_offering INTEGER)
AS $$
BEGIN
    RETURN QUERY (
        SELECT *
        FROM popular_courses_driver()
        ORDER BY output_num_registration_latest_offering DESC, output_course_id ASC
    );

END
$$ LANGUAGE plpgsql;

-- 29.view_summary_report: 
/*
This routine is used to view a monthly summary report of the company’s sales and expenses for a specified number of months. 
The input to the routine is a number of months (say N) and the routine returns a table of records consisting of the following information for each of the last N months (starting from the current month): 
    month and year, total salary paid for the month, total amount of sales of course packages for the month, total registration fees paid via credit card payment for the month, 
    total amount of refunded registration fees (due to cancellations) for the month, and total number of course registrations via course package redemptions for the month. 
For example, if the number of specified months is 3 and the current month is January 2021, the output will consist of one record for each of the following three months: January 2021, December 2020, and November 2020.
*/

CREATE OR REPLACE FUNCTION view_summary_report(IN num_of_months INTEGER)
RETURNS TABLE(year INTEGER, month INTEGER, total_salary_paid NUMERIC(12,2), total_sales NUMERIC(12,2), 
    total_registration_fees NUMERIC(12,2), refund_amount NUMERIC(12,2), num_of_redemption INTEGER) AS $$
DECLARE
    current_month INTEGER;
    current_year INTEGER;
    counter INTEGER;
BEGIN
    counter := 0;  
    SELECT EXTRACT(MONTH FROM CURRENT_DATE) INTO current_month;
    SELECT EXTRACT(YEAR FROM CURRENT_DATE) INTO current_year;

    LOOP
        EXIT WHEN counter = num_of_months;

        IF current_month < 1 THEN
            current_month := 12;
            current_year := current_year - 1;
        ELSE
            -- Computation of each components
            year := current_year;
			month := current_month;

            SELECT SUM(amount) FROM Pay_slips INTO total_salary_paid
            WHERE EXTRACT(MONTH FROM payment_date) = current_month 
            AND EXTRACT(YEAR FROM payment_date) = current_year;

            SELECT SUM(price) INTO total_sales FROM Buys NATURAL JOIN Course_packages
            WHERE EXTRACT(MONTH FROM purchase_date) = current_month 
            AND EXTRACT(YEAR FROM purchase_date) = current_year;

            SELECT SUM(fees) INTO total_registration_fees FROM Registers NATURAL JOIN Offerings
            WHERE EXTRACT(MONTH FROM registration_date) = current_month 
            AND EXTRACT(YEAR FROM registration_date) = current_year;

            SELECT SUM(refund_amt) INTO refund_amount FROM Cancels
            WHERE EXTRACT(MONTH FROM cancellation_date) = current_month 
            AND EXTRACT(YEAR FROM cancellation_date) = current_year;

            SELECT COUNT(*) INTO num_of_redemption FROM Redeems
            WHERE EXTRACT(MONTH FROM redemption_date) = current_month 
            AND EXTRACT(YEAR FROM redemption_date) = current_year;

            current_month := current_month - 1;
            counter := counter + 1;

            RETURN NEXT;

            
        END IF;

    END LOOP; 
END;
$$ LANGUAGE plpgsql;

-- 30.view_manager_report: 
/*
This routine is used to view a report on the sales generated by each manager. 
The routine returns a table of records consisting of the following information for each manager: 
    manager name, total number of course areas that are managed by the manager, total number of course offerings that ended this year (i.e., the course offering’s end date is within this year) that are managed by the manager, 
    total net registration fees for all the course offerings that ended this year that are managed by the manager, 
    the course offering title (i.e., course title) that has the highest total net registration fees among all the course offerings that ended this year that are managed by the manager; 
        if there are ties, list all these top course offering titles. 
The total net registration fees for a course offering is defined to be the sum of the total registration fees paid for the course offering via credit card payment (excluding any refunded fees due to cancellations) 
and the total redemption registration fees for the course offering. 
The redemption registration fees for a course offering refers to the registration fees for a course offering that is paid via a redemption from a course package; 
    this registration fees is given by the price of the course package divided by the number of sessions included in the course package (rounded down to the nearest dollar). 
There must be one output record for each manager in the company and the output is to be sorted by ascending order of manager name.
*/
CREATE OR REPLACE FUNCTION view_manager_report()
RETURNS TABLE(manager_name TEXT, total_num_of_course_areas_managed INTEGER, total_number_of_course_offerings_ended_this_year INTEGER, total_net_reg_fees NUMERIC(12,2), highest_total_course_offerings TEXT[]) AS $$
DECLARE
	curs1 CURSOR FOR (SELECT eid, name FROM Employees natural join Managers ORDER BY name);
	r1 RECORD;
	
	curs2 refcursor;
	r2 RECORD;
	
	total_count_from_credit_card INTEGER;
	total_sum_from_credit_card NUMERIC;
	total_sum_from_redemption NUMERIC;
	highest_amount NUMERIC;
	highest_course_id INTEGER[];
	temp_course_id INTEGER;
	highest_total_offering TEXT[];
	current_year INTEGER = (SELECT EXTRACT('YEAR' FROM CURRENT_DATE));
	
BEGIN
	OPEN curs1;
	LOOP
		FETCH curs1 into r1;
		EXIT WHEN NOT FOUND;
		manager_name := r1.name;
		total_num_of_course_areas_managed := (SELECT count(*) FROM course_areas C where C.eid = r1.eid);
		total_number_of_course_offerings_ended_this_year := (SELECT count(*) FROM (course_areas natural join Courses) AS C join Offerings O on C.course_id = O.course_id where C.eid = r1.eid and EXTRACT('YEAR'FROM end_date) = current_year);
		
		-- for each manager so initialize to 0 every loop
		total_sum_from_credit_card := 0.00;
		total_sum_from_redemption := 0.00;
		highest_amount := -1;
		highest_course_id := '{}';
		highest_total_offering := '{}';
		
		OPEN curs2 FOR (SELECT * FROM (course_areas natural join Courses) AS C join Offerings O on C.course_id = O.course_id where C.eid = r1.eid and EXTRACT('YEAR' FROM end_date) = current_year);
		LOOP
			FETCH curs2 into r2;
			EXIT WHEN NOT FOUND;
			SELECT count(*) into total_count_from_credit_card
			from Registers
			where course_id = r2.course_id and launch_date = r2.launch_date;

			total_sum_from_credit_card := total_sum_from_credit_card + total_count_from_credit_card * r2.fees;
			total_sum_from_redemption := total_sum_from_redemption + (SELECT COALESCE(SUM(price/num_free_registrations),0) from course_packages natural join Redeems where course_id = r2.course_id and launch_date = r2.launch_date);
			
			IF (total_sum_from_credit_card + total_sum_from_redemption > highest_amount) THEN
				highest_amount := total_sum_from_credit_card + total_sum_from_redemption;
				highest_course_id := array_append(NULL,r2.course_id);
			ELSIF (total_sum_from_credit_card + total_sum_from_redemption = highest_amount) THEN
				highest_course_id := array_append(highest_course_id,r2.course_id);
			END IF;
		END LOOP;
		close curs2;
		
		total_net_reg_fees := total_sum_from_credit_card + total_sum_from_redemption;
		
		FOREACH temp_course_id IN ARRAY highest_course_id
		LOOP
			highest_total_offering := array_append(highest_total_offering, (SELECT title FROM Courses WHERE course_id = temp_course_id));
		END LOOP;
		
		highest_total_course_offerings := highest_total_offering;
		
		RETURN NEXT;
	
	END LOOP;
	CLOSE curs1;
END;
$$ LANGUAGE plpgsql;
/* ============================================================== TRIGGERS ============================================================== */

/* === No two sessions for the same course offering can be conducted on the same day and at the same time. === */
/* ============== CHECKS BASED ON DRAWING IN ./drawings IF THERE'S SUCH A SESSION THAT EXISTS ============== */
CREATE OR REPLACE FUNCTION NO_SESS_SAME_CSE_SAME_DAY_AND_TIME()
RETURNS TRIGGER AS $$
DECLARE
    counter INTEGER;
BEGIN
    counter := (
        SELECT COALESCE(COUNT(*), 0)
            FROM Sessions
            WHERE (course_id = NEW.course_id AND launch_date = NEW.launch_date AND session_date = NEW.session_date) AND
                ((NEW.start_time < start_time AND NEW.start_time < end_time AND NEW.end_time > start_time AND NEW.end_time <= end_time) OR
                (NEW.start_time >= start_time AND NEW.start_time < end_time AND NEW.end_time > start_time AND NEW.end_time > end_time) OR
                (NEW.start_time >= start_time AND NEW.start_time <= end_time AND NEW.end_time >= start_time AND NEW.end_time <= end_time) OR
                (NEW.start_time < start_time AND NEW.start_time < end_time AND NEW.end_time > start_time AND NEW.end_time > end_time)
                )
        );

    IF(counter <> 0) THEN
        RAISE EXCEPTION 'Clashes with existing session(s)!';
        RETURN NULL;
    ELSE 
        RETURN NEW;
    END IF;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER NO_SESS_SAME_CSE_SAME_DAY_AND_TIME_TRIGGER
BEFORE INSERT OR UPDATE ON Sessions
FOR EACH ROW EXECUTE FUNCTION NO_SESS_SAME_CSE_SAME_DAY_AND_TIME();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION AT_MOST_ONE_REG_BEFORE_DEADLINE_PER_CUSTOMER()
RETURNS TRIGGER AS $$
DECLARE
    counter INTEGER;
    reg_deadline DATE;
BEGIN

    reg_deadline := (SELECT o.registration_deadline
                        FROM Offerings as o
                        WHERE NEW.course_id = course_id AND 
                            NEW.launch_date = launch_date);
    
    IF (NEW.registration_date > reg_deadline) THEN
        RAISE EXCEPTION 'You are registering after the deadline!';
        RETURN NULL;
    END IF;

    counter := (
        SELECT COALESCE(COUNT(card_number), 0) -- this query returns the count of credit cards insert customer owns that exist in registers table AND reg_date < deadline
        FROM Registers as r NATURAL FULL JOIN Redeems as re NATURAL JOIN Sessions as s NATURAL JOIN (SELECT course_id, launch_date, registration_deadline FROM Offerings) as co
        WHERE card_number IN (SELECT DISTINCT occ.card_number -- this subquery gets all the credit cards this customer owns
                FROM Owns_Credit_Cards as occ
                WHERE cust_id in (SELECT DISTINCT rcc.cust_id -- this subquery fetches customers who own NEW.credit card
                    FROM (Registers NATURAL FULL JOIN Redeems NATURAL JOIN Owns_Credit_Cards) as rcc JOIN Customers as c ON rcc.cust_id = c.cust_id
                    WHERE NEW.card_number = card_number))
            AND NEW.registration_date <= registration_deadline
            AND NEW.course_id = course_id
            AND NEW.launch_date = launch_date
    );

    IF(counter <> 0) THEN
        RAISE EXCEPTION 'A Customer can only register or redeems for atmost one session from an offered course!';
        RETURN NULL;
    ELSE 
        RETURN NEW;
    END IF;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER AT_MOST_ONE_REG_BEFORE_DEADLINE_PER_CUSTOMER_TRIGGER
BEFORE INSERT OR UPDATE ON Registers
FOR EACH ROW EXECUTE FUNCTION AT_MOST_ONE_REG_BEFORE_DEADLINE_PER_CUSTOMER();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION SEATING_CAPACITY_COURSE_EQUAL_SUM_OF_SESSIONS()
RETURNS TRIGGER AS $$
DECLARE
    total_capacity INTEGER;
BEGIN
    IF (TG_OP = 'DELETE') THEN
    -- old here means what was deleted
        total_capacity := (SELECT SUM(COALESCE(seating_capacity, 0))
                    FROM Sessions as s NATURAL JOIN Rooms as r
                    WHERE OLD.course_id = s.course_id AND
                        OLD.launch_date = s.launch_date);

        UPDATE Offerings SET seating_capacity = total_capacity 
        WHERE course_id = OLD.course_id 
            AND launch_date = OLD.launch_date;

        RETURN NEW;
    ELSE
        total_capacity := (SELECT SUM(COALESCE(seating_capacity, 0))
                            FROM Sessions as s NATURAL JOIN Rooms as r
                            WHERE NEW.course_id = s.course_id AND
                                NEW.launch_date = s.launch_date);

        UPDATE Offerings SET seating_capacity = total_capacity 
        WHERE course_id = NEW.course_id 
            AND launch_date = NEW.launch_date;

        RETURN NEW;
    END IF;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER SEATING_CAPACITY_COURSE_EQUAL_SUM_OF_SESSIONS_TRIGGER
AFTER INSERT OR UPDATE OR DELETE ON Sessions
FOR EACH ROW EXECUTE FUNCTION SEATING_CAPACITY_COURSE_EQUAL_SUM_OF_SESSIONS();

CREATE OR REPLACE FUNCTION ROOMS_CAPACITY_CHANGE()
RETURNS TRIGGER AS $$
DECLARE
    total_capacity INTEGER;
    r record;
    curs CURSOR FOR (SELECT SUM(COALESCE(seating_capacity, 0)) as total_capacity, s.course_id, s.launch_date
                    FROM Sessions as s NATURAL JOIN Rooms as r
                    WHERE (s.course_id, s.launch_date, s.sid) IN (SELECT s2.course_id, s2.launch_date, s2.sid
                            FROM Sessions as s2
                            WHERE NEW.rid = s2.rid)
            GROUP BY s.course_id, s.launch_date);
BEGIN

    OPEN curs;
    LOOP
        FETCH curs into r; 
        EXIT WHEN NOT FOUND;

        UPDATE Offerings 
        SET seating_capacity = r.total_capacity 
        WHERE r.course_id = course_id AND r.launch_date = launch_date;

    END LOOP;

    RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER ROOMS_CAPACITY_CHANGE_TRIGGER
AFTER UPDATE ON Rooms
FOR EACH ROW EXECUTE FUNCTION ROOMS_CAPACITY_CHANGE();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION CSE_OFFERING_AVAIL()
RETURNS TRIGGER AS $$
DECLARE
    avail_capacity INTEGER;
    before_add_capacity_registers INTEGER;
    before_add_capacity_redeems INTEGER;
    before_add_capacity INTEGER;
BEGIN
    avail_capacity := (SELECT o.seating_capacity
                        FROM Offerings as o
                        WHERE NEW.course_id = course_id AND 
                            NEW.launch_date = launch_date);

    /* this works because Sessions is a weak entity set to Offerings */
    before_add_capacity_registers := (SELECT COUNT(*)
                            FROM Registers
                            WHERE NEW.course_id = course_id AND 
                            NEW.launch_date = launch_date AND 
                            NEW.sid = sid);

    before_add_capacity_redeems := (
        SELECT COUNT(*)
        FROM Redeems
        WHERE NEW.course_id = course_id AND 
        NEW.launch_date = launch_date AND 
        NEW.sid = sid
    );

    before_add_capacity := before_add_capacity_redeems + before_add_capacity_registers;
    
    IF (avail_capacity - before_add_capacity <= 0) THEN
        RAISE EXCEPTION 'Course offering is fully booked!';
        RETURN NULL;
    ELSE
        RETURN NEW;
    END IF;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER CSE_OFFERING_AVAIL_TRIGGER
BEFORE INSERT ON Registers
FOR EACH ROW EXECUTE FUNCTION CSE_OFFERING_AVAIL();

/* ============================================================================================================ */

-- For each course offered by the company, a customer can register for at most one of its sessions before its registration_deadline.
-- This means that customer can only redeem (register) each sessions also
CREATE OR REPLACE FUNCTION at_most_one_redeem_session_in_offerings_func()
RETURNS TRIGGER AS $$
DECLARE
	offerings_deadline DATE;
	is_registered INTEGER;
	is_redeemed INTEGER;
BEGIN
	SELECT registration_deadline INTO offerings_deadline
	FROM Offerings
	WHERE Offerings.course_id = NEW.course_id
	AND Offerings.launch_date = NEW.launch_date;
	
	IF NEW.redemption_date > offerings_deadline THEN
		RAISE EXCEPTION 'You are too late to redeem for this course session';
	ELSE
		SELECT COUNT(*) INTO is_registered FROM Registers
		WHERE Registers.course_id = NEW.course_id
		AND Registers.launch_date = NEW.launch_date
		AND Registers.card_number = NEW.card_number;
		
		IF is_registered > 0 THEN
			RAISE EXCEPTION 'This customer has already registered this course offerings';
		ELSE
			SELECT COUNT(*) INTO is_redeemed FROM Redeems
			WHERE Redeems.course_id = NEW.course_id
			AND Redeems.launch_date = NEW.launch_date
			AND Redeems.card_number = NEW.card_number;
			
			IF is_redeemed > 0 THEN
				RAISE EXCEPTION 'This customer has already redeemed this course offerings';
			ELSE
				RETURN NEW;
			END IF;
		END IF;
	END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER at_most_one_redeem_session_in_offerings
BEFORE INSERT ON Redeems
FOR EACH ROW
EXECUTE FUNCTION at_most_one_redeem_session_in_offerings_func();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION check_unique_instances_for_managers()
RETURNS TRIGGER AS $$
DECLARE
	count_administrator INTEGER;
	count_instructor INTEGER;
BEGIN
	SELECT COUNT(*) INTO count_administrator
	FROM administrators
	WHERE NEW.eid = administrators.eid;
	
	SELECT COUNT(*) INTO count_instructor
	FROM instructors
	WHERE NEW.eid = instructors.eid;
	
	IF (count_administrator > 0) OR (count_instructor > 0) THEN
		RAISE NOTICE 'OPERATION FAILED: Current Employee exist in Administrators or Instructors';
		RETURN NULL;
	ELSE 
		RETURN NEW;
	END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_unique_instances_for_managers
BEFORE INSERT OR UPDATE ON Managers
FOR EACH ROW EXECUTE FUNCTION check_unique_instances_for_managers();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION check_unique_instances_for_administrators()
RETURNS TRIGGER AS $$
DECLARE
	count_manager INTEGER;
	count_instructor INTEGER;
BEGIN
	SELECT COUNT(*) INTO count_manager
	FROM managers
	WHERE NEW.eid = managers.eid;
	
	SELECT COUNT(*) INTO count_instructor
	FROM instructors
	WHERE NEW.eid = instructors.eid;
	
	IF (count_manager > 0) OR (count_instructor > 0) THEN
		RAISE NOTICE 'OPERATION FAILED: Current Employee exist in Managers or Instructors';
		RETURN NULL;
	ELSE 
		RETURN NEW;
	END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_unique_instances_for_administrators
BEFORE INSERT OR UPDATE ON Administrators
FOR EACH ROW EXECUTE FUNCTION check_unique_instances_for_administrators();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION check_unique_instances_for_instructors()
RETURNS TRIGGER AS $$
DECLARE
	count_manager INTEGER;
	count_administrator INTEGER;
BEGIN
	SELECT COUNT(*) INTO count_manager
	FROM managers
	WHERE NEW.eid = managers.eid;
	
	SELECT COUNT(*) INTO count_administrator
	FROM administrators
	WHERE NEW.eid = administrators.eid;
	
	IF (count_manager > 0) OR (count_administrator > 0) THEN
		RAISE NOTICE 'OPERATION FAILED: Current Employee exist in Managers or Administrators';
		RETURN NULL;
	ELSE 
		RETURN NEW;
	END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_unique_instances_for_instructors
BEFORE INSERT OR UPDATE ON Instructors
FOR EACH ROW EXECUTE FUNCTION check_unique_instances_for_instructors();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION check_unique_instances_for_full_time_emp()
RETURNS TRIGGER AS $$
DECLARE
	count_part_timer INTEGER;
BEGIN
	SELECT COUNT(*) INTO count_part_timer
	FROM part_time_emp
	WHERE NEW.eid = part_time_emp.eid;
	
	IF count_part_timer > 0 THEN
		RAISE NOTICE 'OPERATION FAILED: Current Employee exist in Part Timer Employee';
		RETURN NULL;
	ELSE 
		RETURN NEW;
	END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_unique_instances_for_full_time_emp
BEFORE INSERT OR UPDATE ON Full_time_emp
FOR EACH ROW EXECUTE FUNCTION check_unique_instances_for_full_time_emp();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION check_unique_instances_for_part_time_emp()
RETURNS TRIGGER AS $$
DECLARE
	count_full_timer INTEGER;
BEGIN
	SELECT COUNT(*) INTO count_full_timer
	FROM full_time_emp
	WHERE NEW.eid = full_time_emp.eid;
	
	IF count_full_timer > 0 THEN
		RAISE NOTICE 'OPERATION FAILED: Current Employee exist in Full Timer Employee';
		RETURN NULL;
	ELSE 
		RETURN NEW;
	END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_unique_instances_for_part_time_emp
BEFORE INSERT OR UPDATE ON Part_time_emp
FOR EACH ROW EXECUTE FUNCTION check_unique_instances_for_part_time_emp();

/* ============================================================================================================ */

-- Each instructor can teach at most one course session at any hour.

CREATE OR REPLACE FUNCTION check_instructor_overlap_session_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs CURSOR FOR (SELECT * FROM Sessions WHERE Sessions.session_date = NEW.session_date AND NEW.eid = Sessions.eid);
    r RECORD;
BEGIN
    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        IF (NEW.start_time, NEW.end_time) OVERLAPS (r.start_time, r.end_time) THEN
                CLOSE curs;
                RAISE EXCEPTION 'Instructor can teach at most one course session at any hour';
        END IF;
    END LOOP;
    CLOSE curs;
    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_instructor_overlap_session
BEFORE INSERT OR UPDATE
ON Sessions
FOR EACH ROW
EXECUTE FUNCTION check_instructor_overlap_session_func();

/* ============================================================================================================ */

--  Each part-time instructor must not teach more than 30 hours for each month.

CREATE OR REPLACE FUNCTION max_work_hour_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs CURSOR FOR (SELECT * FROM Sessions WHERE Sessions.eid = NEW.eid AND NEW.eid IN (SELECT eid FROM Part_time_instructors)
        AND EXTRACT(month from Sessions.session_date) = EXTRACT(month FROM NEW.session_date));
    r RECORD;
    total_work_hours INTERVAL;
BEGIN
    total_work_hours:= INTERVAL '0 hours';
    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        total_work_hours:= total_work_hours +  (r.end_time - r.start_time);
    END LOOP;
    CLOSE curs;

    total_work_hours := total_work_hours + (NEW.end_time - NEW.start_time);
    IF total_work_hours <= INTERVAL '30 hours' THEN
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'Each part-time instructor must not teach more than 30 hours for each month.';
    END IF;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER max_work_hour
BEFORE INSERT OR UPDATE
ON Sessions
FOR EACH ROW
EXECUTE FUNCTION max_work_hour_func();

/* ============================================================================================================ */

--  An instructor who is assigned to teach a course session must be specialized in that course area.

CREATE OR REPLACE FUNCTION valid_course_instructor_assignment_func()
RETURNS TRIGGER AS
$$
DECLARE
    session_course_area TEXT;
BEGIN
    SELECT name INTO session_course_area
    FROM Courses
    WHERE Courses.course_id = NEW.course_id;

    IF NEW.course_area = session_course_area THEN
        RETURN NEW;
    ElSE
        RAISE EXCEPTION 'An instructor who is assigned to teach a course session must be specialized in that course area.';
    END IF;
END;
$$
LANGUAGE plpgsql;


CREATE TRIGGER valid_course_instructor_assignment
BEFORE INSERT OR UPDATE
ON Sessions
FOR EACH ROW
EXECUTE FUNCTION valid_course_instructor_assignment_func();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION at_most_one_redeemed_session_in_offerings_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs1 CURSOR FOR (SELECT card_number FROM Owns_Credit_Cards O1 WHERE 
        O1.cust_id in (
            SELECT cust_id FROM Owns_Credit_Cards O2 WHERE O2.card_number = NEW.card_number
        )
    );
    r RECORD;
    offerings_deadline DATE;
    is_registered INTEGER;
    is_redeemed INTEGER;
BEGIN
    SELECT registration_deadline INTO offerings_deadline
    FROM Offerings
    WHERE Offerings.course_id = NEW.course_id
    AND Offerings.launch_date = NEW.launch_date;

    IF NEW.redemption_date > offerings_deadline THEN
        RAISE EXCEPTION 'You are too late to redeem for this course session';
    ELSE
        OPEN curs1;
        LOOP
            FETCH curs1 INTO r;
            EXIT WHEN NOT FOUND;

            SELECT COUNT(*) INTO is_registered FROM Registers
            WHERE Registers.course_id = NEW.course_id
            AND Registers.launch_date = NEW.launch_date
            AND Registers.card_number = r.card_number;

            IF is_registered > 0 THEN
                CLOSE curs1;
                RAISE EXCEPTION 'This customer has already registered this course offerings';
            END IF;

            SELECT COUNT(*) INTO is_redeemed FROM Redeems
            WHERE Redeems.course_id = NEW.course_id
            AND Redeems.launch_date = NEW.launch_date
            AND Redeems.card_number = r.card_number;

            IF is_redeemed > 0 THEN
                CLOSE curs1;
                RAISE EXCEPTION 'This customer has already redeemed this course offerings';
            END IF;
        END LOOP;
        CLOSE curs1;
        RETURN NEW; -- The customer did not redeem or register this course yet.
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER at_most_one_redeemed_session_in_offerings
BEFORE INSERT
ON Redeems
FOR EACH ROW
EXECUTE FUNCTION at_most_one_redeemed_session_in_offerings_func();

/* ============================================================================================================ */

-- For each course offered by the company, a customer can register for at most one of its sessions before its registration deadline

CREATE OR REPLACE FUNCTION at_most_one_registered_session_in_offerings_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs CURSOR FOR (SELECT card_number FROM Owns_Credit_Cards O1 WHERE 
        O1.cust_id in (
            SELECT cust_id FROM Owns_Credit_Cards O2 WHERE O2.card_number = NEW.card_number
        )
    );
    r RECORD;
    offerings_deadline DATE;
    is_registered INTEGER;
    is_redeemed INTEGER;
BEGIN
    SELECT registration_deadline INTO offerings_deadline
    FROM Offerings
    WHERE Offerings.course_id = NEW.course_id
    AND Offerings.launch_date = NEW.launch_date;

    IF NEW.registration_date > offerings_deadline THEN
        RAISE EXCEPTION 'You are too late to register for this course session';
    ELSE
        OPEN curs;
        LOOP
            FETCH curs INTO r;
            EXIT WHEN NOT FOUND;

            SELECT COUNT(*) INTO is_registered FROM Registers
            WHERE Registers.course_id = NEW.course_id
            AND Registers.launch_date = NEW.launch_date
            AND Registers.card_number = r.card_number;

            IF is_registered > 0 THEN
                CLOSE curs;
                RAISE EXCEPTION 'This customer has already registered this course offerings';
            END IF;

            SELECT COUNT(*) INTO is_redeemed FROM Redeems
            WHERE Redeems.course_id = NEW.course_id
            AND Redeems.launch_date = NEW.launch_date
            AND Redeems.card_number = r.card_number;

            IF is_redeemed > 0 THEN
                CLOSE curs;
                RAISE EXCEPTION 'This customer has already redeemed this course offerings';
            END IF;
        END LOOP;
        CLOSE curs;
        RETURN NEW; -- The customer did not redeem or register this course yet.
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER at_most_one_registered_session_in_offerings
BEFORE INSERT
ON Registers
FOR EACH ROW
EXECUTE FUNCTION at_most_one_registered_session_in_offerings_func();

/* ============================================================================================================ */

-- Each instructor must not be assigned to teach two consecutive course sessions

CREATE OR REPLACE FUNCTION check_consec_course_session_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs CURSOR FOR (SELECT * FROM Sessions WHERE Sessions.session_date = NEW.session_date AND Sessions.eid = NEW.eid);
    r RECORD;
BEGIN
    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        IF ((NEW.start_time - r.start_time >= INTERVAL '0 hour') AND
            (NEW.start_time- r.end_time < INTERVAL '1 hour')) OR
            ((NEW.end_time - r.start_time <= INTERVAL '0 hour') AND
            (r.start_time - NEW.end_time < INTERVAL '1 hour')) THEN
            CLOSE curs;
            RAISE EXCEPTION 'No instructor can be assigned to teach two consecutive course sessions';
        END IF;
    END LOOP;
    CLOSE curs;
    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_consec_course_session
BEFORE INSERT OR UPDATE
ON Sessions
FOR EACH ROW
EXECUTE FUNCTION check_consec_course_session_func();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION refund_session_func()
RETURNS TRIGGER AS
$$
DECLARE
    curs CURSOR FOR (SELECT card_number FROM Owns_credit_cards WHERE Owns_credit_cards.cust_id = NEW.cust_id);
    r RECORD;
    is_found INTEGER; -- We need to run through all the cards that customers has to check which card he/she used.
    package_used_for_redemption INTEGER; 
BEGIN
    is_found = 0;
    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        IF NEW.package_credit > 0 THEN
            SELECT COUNT(*) INTO is_found FROM Redeems
            WHERE Redeems.course_id = NEW.course_id
            AND Redeems.launch_date = NEW.launch_date
            AND Redeems.sid = NEW.sid
            AND Redeems.card_number = r.card_number;

            IF is_found > 0 THEN
                SELECT package_id INTO package_used_for_redemption FROM Redeems
                WHERE Redeems.course_id = NEW.course_id
                AND Redeems.launch_date = NEW.launch_date
                AND Redeems.sid = NEW.sid
                AND Redeems.card_number = r.card_number;

                UPDATE Buys SET num_of_redemption = num_of_redemption + 1 -- add num_remaining_redemptions in buys
                WHERE Buys.card_number = r.card_number
                AND package_id = package_used_for_redemption;

                DELETE FROM Redeems -- delete the entry in redeems
                WHERE Redeems.course_id = NEW.course_id
                AND Redeems.launch_date = NEW.launch_date
                AND Redeems.sid = NEW.sid
                AND Redeems.card_number = r.card_number;

                CLOSE CURS;
                RETURN NEW;
            END IF;

        ELSE
            SELECT COUNT(*) INTO is_found FROM Registers
            WHERE Registers.course_id = NEW.course_id
            AND Registers.launch_date = NEW.launch_date
            AND Registers.sid = NEW.sid
            AND Registers.card_number = r.card_number;

            IF is_found > 0 THEN
                DELETE FROM Registers -- delete the row in registers
                WHERE Registers.course_id = NEW.course_id
                AND Registers.launch_date = NEW.launch_date
                AND Registers.sid = NEW.sid
                AND Registers.card_number = r.card_number;
                CLOSE curs;
                RETURN NEW;
            END IF;
        END IF;
    END LOOP;
    CLOSE curs;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER refund_session
BEFORE INSERT OR UPDATE
ON Cancels
FOR EACH ROW
EXECUTE FUNCTION refund_session_func();

/* ============================================================================================================ */

CREATE OR REPLACE FUNCTION receive_dupl_cancels_func() -- Allows a customer to cancels same course offering in the same day 
RETURNS TRIGGER AS
$$
DECLARE
    is_exist INTEGER;
    is_redeemed INTEGER;
BEGIN
    IF NEW.package_credit > 0 THEN
        is_redeemed := NEW.package_credit;
    ELSE
        is_redeemed := 0;
    END IF;

    SELECT COUNT(*) INTO is_exist FROM Cancels
    WHERE NEW.cust_id = Cancels.cust_id
    AND NEW.course_id = Cancels.course_id
    AND NEW.launch_date = Cancels.launch_date
    AND NEW.sid = Cancels.sid
    AND NEW.cancellation_date = Cancels.cancellation_date;

    IF is_exist > 0 THEN
        IF is_redeemed > 0 THEN
            UPDATE Cancels SET package_credit = package_credit + 1
            WHERE NEW.cust_id = Cancels.cust_id
            AND NEW.course_id = Cancels.course_id
            AND NEW.launch_date = Cancels.launch_date
            AND NEW.sid = Cancels.sid
            AND NEW.cancellation_date = Cancels.cancellation_date;
        ELSE  -- Customer cancels the register.
            UPDATE Cancels SET refund_amt = refund_amt + NEW.refund_amt
            WHERE NEW.cust_id = Cancels.cust_id
            AND NEW.course_id = Cancels.course_id
            AND NEW.launch_date = Cancels.launch_date
            AND NEW.sid = Cancels.sid
            AND NEW.cancellation_date = Cancels.cancellation_date;
        END IF;
        RETURN NULL; -- This will prevent any insertion of duplicated record which will violates the PK
    END IF;
    RETURN NEW; -- NEW record.
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER receive_dupl_cancels
BEFORE INSERT
ON Cancels
FOR EACH ROW
EXECUTE FUNCTION receive_dupl_cancels_func();